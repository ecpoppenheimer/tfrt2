import numpy as np
import tensorflow as tf
import tfquaternion as tfq
import PyQt5.QtGui as qtg
import PyQt5.QtWidgets as qtw

import tfrt2.src.settings as settings
import tfrt2.src.component_widgets as cw
import tfrt2.src.wavelength as wv


class Source3D:
    """
    A three-dimensional ray source built from starting points, angles, and wavelengths

    All 3D sources are built centered on the origin with the rays starting on the x-y plane and the center of the
    output distribution pointing along the z-axis.  After these points are calculated, the source then rotates itself
    so it points along the direction specified in settings and then translates itself so it is centered at the
    position specified in settings.

    The public attributes listed below, or at least most of them, get updated on calling update().  This means that,
    if you are setting up the design problem as an imaging problem, you can get the starting points of the rays (points
    on the image) in order to set up the goal.

    Public Attributes
    -----------------
    rotation : tfq.Quaternion
        A quaternion representing a rotation from the base orientation ((0, 0, 1), the z-axis) to angle.  Should
        be set in the settings (angle, a vector, not a quaternion) and generated by calling update_rotation()
    translation : tf.constant with shape (1, 3)
        A translation vector applied to the source to move it.  Should be set in the settings (center) and generated
        by calilng update_translation()
    start_points : tf.constant with shape (n, 3)
        The starting points of the rays, transformed
    base_start_points : tf.constant with shape (n, 3)
        The starting points, without the transformation applied.  These should be centered around the origin and
        pointing toward the z-axis.  These can be used to derive the goal in an imaging problem.
    end_points : tf.constant with shape (n, 3)
        The ending points of the rays, transformed
    base_end_points : tf.constant with shape (n, 3)
        The ending points, without the transformation applied.  These should be centered around the origin and
        pointing toward the z-axis.
    angles: tf.constant with shape (n, 3), or None
        The angles of the rays, transformed, as a vector.  Only valid if in angular mode, otherwise this is None.
    base_angles : tf.constant with shape (n, 3)
        The angles without the transformation applied.  Only valid if in angular mode, otherwise this is None.
    wavelengths : tf.constant with shape (n,)
        The wavelengths of each ray.
    rays : the ray data concatenated into a single block.  The structure is given in SIG.
    """
    SIG = {
        "x_start": 0,
        "y_start": 1,
        "z_start": 2,
        "start": slice(0, 3, None),
        "x_end": 3,
        "y_end": 4,
        "z_end": 5,
        "end": slice(3, 6, None),
        "wavelength": 6,
    }
    BASE_ORIENTATION = tf.constant(((0.0, 0.0, 1.0),), dtype=tf.float64)
    dimension = 3

    def __init__(
        self, settings, wavelength, system_path, base_points=None, angles=None, aperture=None, aperture_distance=1.0
    ):
        """
        Parameters
        ----------
        settings : settings.Settings
            The settings for this component.
        wavelength :
            Many options for this parameter, that change how the class functions.
            If it is a callable:
                Must be a function that accepts an int, and generates an array containing that many floats which are
                the wavelengths in nanometers.
            If it is a wavelength.Spectrum:
                Will use this spectrum to generate the wavelengths.  See wavelength.Spectrum for details.
            If it is a str:
                Will be interpreted as a file path to a spectrum.  See wavelength.Spectrum for details.  Will generate a
                file selector widget to find this spectrum, and this parameter will only be used to set the default
                spectrum.
            If it is a float:
                Will be a constant used for all wavelengths.  Will generate a setting, 'wavelength' and a controller
                widget to make this parameter adjustable from the client.
            If it is a 2-tuple of floats:
                Will form a uniform spectrum between these two endpoints.  Will generate two settings, 'min_wavelength'
                and 'max_wavelength' and a controller to make these parameters adjustable from the client.
        base_points : distribution or None
            If None, this source will be a point source, with all rays emanating from a single point, the center set
            in the settings.  If non-none, this must be a callable that acts like a 2D distribution.  May also be a
            2d cumdistf distribution.  It must take a 2D set of points between zero and one and map them to some other
            distribution in 2D.  These points should be centered around the origin and will be treated as lying in the
            x=y plane.  The source assumes this position when translating and rotating the points into their final
            position.
        angles
        aperture
        aperture_distance : float, optional
            The distance between the optic center and the aperture.  Defaults to 1.  Only has an effect if aperture
            is specified.
        """
        self.settings = settings
        self.name = None
        self.settings.establish_defaults(
            ray_count=100,
            center=[0.0, 0.0, 0.0],
            angle=[0.0, 0.0, 1.0],
        )
        self.controller_widgets = [SourceController(self)]
        self.system_path = system_path

        self.make_wavelengths = self._process_wavelength(wavelength)
        self.base_points = self._register_controller(base_points)

        if angles is None:
            if aperture is None:
                raise ValueError("Source3D: Either angles or aperature must be specified")
            else:
                # in aperature mode
                self.make_end_points = self._register_controller(aperture)
                self.settings.establish_defaults(aperture_distance=aperture_distance)
                self.controller_widgets.append(cw.SettingsEntryBox(
                    self.settings, "aperture_distance", float, qtg.QDoubleValidator(1e-9, 1e6, 10)
                ))
        else:
            if aperture is None:
                # in angles mode
                self.make_end_points = self._register_controller(angles)
            else:
                raise ValueError("Source3D: Only one of angles or aperature can be specified - not both.")

        self.rotation = None
        self.update_rotation()
        self.translation = None
        self.update_translation()
        self.start_points = tf.zeros((0, 3), dtype=tf.float64)
        self.base_start_points = tf.zeros((0, 3), dtype=tf.float64)
        self.angles = None
        self.base_angles = None
        self.end_points = tf.zeros((0, 3), dtype=tf.float64)
        self.base_end_points = tf.zeros((0, 3), dtype=tf.float64)
        self.wavelengths = tf.zeros((0, 3), dtype=tf.float64)
        self.rays = tf.zeros((0, 7), dtype=tf.float64)

    def update(self):
        if self.settings.source_active:
            start_seed, end_seed, wavelength_seed = self.get_seeds(self.settings.ray_count)
            self.base_start_points = self.make_start_points(start_seed)
            rotated_start_points = tfq.rotate_vector_by_quaternion(self.rotation, self.base_start_points)
            self.start_points = rotated_start_points + self.translation

            base_end_points = self.make_end_points(end_seed)
            if base_end_points.shape[1] == 2:
                # Is an aperture - need to expand
                base_end_points = np.pad(
                    base_end_points, ((0, 0), (0, 1)), constant_values=self.settings.aperture_distance
                )
            self.base_end_points = tf.constant(base_end_points, dtype=tf.float64)
            rotated_end_points = tfq.rotate_vector_by_quaternion(self.rotation, self.base_end_points)
            self.end_points = rotated_end_points + self.translation

            # set up wavelength mode
            self.wavelengths = tf.constant(tf.reshape(
                self.make_wavelengths(wavelength_seed), (-1, 1)
            ), dtype=tf.float64)
        else:
            self.base_start_points = tf.zeros((0, 3), dtype=tf.float64)
            self.start_points = self.base_start_points

            self.base_end_points = tf.zeros((0, 3), dtype=tf.float64)
            self.end_points = self.base_end_points

            # set up wavelength mode
            self.wavelengths = tf.zeros((0, 1), dtype=tf.float64)

        self.rays = tf.concat((self.start_points, self.end_points, self.wavelengths), axis=1)

    @staticmethod
    def get_seeds(count):
        start = np.random.uniform(size=(count, 2))
        end = np.random.uniform(size=(count, 2))
        wavelength = np.random.uniform(size=(count,))
        return start, end, wavelength

    def update_rotation(self):
        self.rotation = tfq.get_rotation_quaternion_from_u_to_v(
            self.BASE_ORIENTATION, np.array((self.settings.angle,), dtype=np.float64), dtype=tf.float64
        )

    def update_translation(self):
        self.translation = tf.constant(self.settings.center, dtype=tf.float64)

    def make_start_points(self, start_seed):
        if self.base_points is None:
            return tf.zeros((start_seed.shape[0], 3), dtype=tf.float64)
        else:
            points = self.base_points(start_seed)
            points = tf.constant(points, dtype=tf.float64)
            return tf.pad(points, ((0, 0), (0, 1)))

    def _process_wavelength(self, wavelength):
        if callable(wavelength):
            return lambda x: tf.constant(wavelength(x), dtype=tf.float64)
        elif type(wavelength) is wv.Spectrum:
            controller = SpectrumController(self, spectrum=wavelength)
            self.controller_widgets.append(controller)
            return controller
        elif type(wavelength) is str:
            controller = SpectrumController(self, path=wavelength)
            self.controller_widgets.append(controller)
            return controller
        else:
            try:
                wavelength = float(wavelength)
                self.settings.establish_defaults(wavelength=wavelength)
                self.controller_widgets.append(cw.SettingsEntryBox(
                    self.settings, "wavelength", float, validator=qtg.QDoubleValidator(1e-3, 1e6, 8)
                ))
                return self._make_constant_wavelengths
            except TypeError:
                try:
                    start, end = wavelength
                    start, end = float(start), float(end)
                    self.settings.establish_defaults(min_wavelength=start, max_wavelength=end)
                    self.controller_widgets.append(cw.SettingsRangeBox(
                        self.settings, "wavelength range", "min_wavelength", "max_wavelength", float,
                        validator=qtg.QDoubleValidator(1e-3, 1e6, 8)
                    ))
                    return self._make_range_wavelengths
                except TypeError:
                    raise TypeError("Source3D: Could not interpret wavelength.")

    def _register_controller(self, arg):
        if isinstance(arg, qtw.QWidget):
            self.controller_widgets.append(arg)
        return arg

    def _make_constant_wavelengths(self, seed):
        return self.settings.wavelength * tf.ones_like(seed, dtype=tf.float64)

    def _make_range_wavelengths(self, seed):
        return seed * (self.settings.max_wavelength - self.settings.min_wavelength) + self.settings.min_wavelength

    def __getitem__(self, key):
        return self.rays[:, self.SIG[key]]


class SourceController(qtw.QWidget):
    def __init__(self, component):
        super().__init__()
        self.component = component

        # build the UI elements
        main_layout = qtw.QVBoxLayout()
        self.setLayout(main_layout)

        sub_layout = qtw.QHBoxLayout()
        sub_layout.addWidget(cw.SettingsEntryBox(
            self.component.settings, "ray_count", int, qtg.QIntValidator(1, 100000)
        ))
        self.component.settings.establish_defaults(source_active=True)
        sub_layout.addWidget(cw.SettingsCheckBox(
            self.component, "Active", "source_active"
        ))
        main_layout.addLayout(sub_layout)
        main_layout.addWidget(cw.SettingsVectorBox(
            self.component, "center", "center", self.component.update_translation
        ))
        main_layout.addWidget(cw.SettingsVectorBox(
            self.component, "central angle", "angle", self.component.update_rotation
        ))


class SpectrumController(qtw.QWidget):
    def __init__(self, source, spectrum=None, path=None):
        self.source = source
        self.settings = source.settings
        self.spectral_plot = None
        super().__init__()
        layout = qtw.QVBoxLayout()
        self.setLayout(layout)
        self.loadable = False
        if path is None:
            if spectrum is None:
                raise ValueError("SpectrumController: either spectrum or path must be specified.")
            else:
                self.spectrum = spectrum
        else:
            if spectrum is not None:
                raise ValueError("SpectrumController: Only one of spectrum and path may be specified.")
            self.loadable = True
            self.settings.establish_defaults(spectrum_filename=str(path))
            layout.addWidget(cw.SettingsFileBox(
                self.settings, "spectrum_filename", self.source.system_path, filter="*.dat", mode="load",
                callback=self.load_spectrum
            ))

            # Checkbox and display for the spectrum
            self.settings.establish_defaults(show_spectrum=False)
            layout.addWidget(
                cw.SettingsCheckBox(self.source, "Show spectrum", "show_spectrum", self.show_spectrum)
            )
            self.plot_widget = cw.MPLWidget(alignment=(0, .25, 1.0, .7))
            self.plot_widget.ax.yaxis.set_visible(False)
            self.plot_widget.ax.set_xlabel("Wavelength (nm)")
            self.plot_widget.setMinimumHeight(250)
            layout.addWidget(self.plot_widget)
            self.show_spectrum()

            self.load_spectrum()

    def load_spectrum(self):
        if self.loadable:
            try:
                self.plot_widget.ax.clear()
                self.spectrum = wv.Spectrum.load(self.settings.spectrum_filename)
                self.spectrum.plot_to_axis(self.plot_widget.ax, 100)
                self.plot_widget.draw()
            except FileNotFoundError:
                print(f"Error loading the spectrum.  Replaced with a default.")
                self.spectrum = wv.Spectrum(((wv.VISIBLE_MIN, wv.VISIBLE_MAX), (1.0, 1.0)))

    def show_spectrum(self):
        if self.settings.show_spectrum:
            self.plot_widget.show()
            self.plot_widget.draw()
        else:
            self.plot_widget.hide()

    def __call__(self, *args, **kwargs):
        return self.spectrum(*args, **kwargs)
