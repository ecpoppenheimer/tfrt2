"""
Sources produce ray sets.  Ray sets are 3-tuples of (start_point (r_s), directio (r_hat), and metadata (r_meta).
"""

from pathlib import Path
import math

import numpy as np
import PyQt5.QtGui as qtg
import PyQt5.QtWidgets as qtw
import tensorflow as tf
import quaternionic as q

import tfrt2.component_widgets as cw
from tfrt2.wavelength import Spectrum


class RaySet3D:
    s_spec = tf.TensorSpec(shape=(None, 3), dtype=tf.float64)
    hat_spec = tf.TensorSpec(shape=(None, 3), dtype=tf.float64)
    wv_spec = tf.TensorSpec(shape=(None,), dtype=tf.float64)
    meta_spec = tf.TensorSpec(shape=(None,), dtype=tf.int32)
    n_spec = tf.TensorSpec(shape=(None, None), dtype=tf.float64)
    dimension = 3

    def __init__(self, s=None, hat=None, wv=None, meta=None):
        """
        Every parameter must either be filled with a numpy array of type np.float64 or every parameter must be None,
        in which case an empty set will be returned.  Data should be numpy arrays.
        """
        if s is None:
            self._s = tf.zeros((0, 3), dtype=np.float64)
        else:
            self.s = s
        if hat is None:
            self._hat = tf.zeros((0, 3), dtype=np.float64)
        else:
            self.hat = hat
        if wv is None:
            self._wv = tf.zeros((0,), dtype=np.float64)
        else:
            self.wv = wv
        if meta is None:
            self._meta = tf.range(self._s.shape[0], dtype=tf.int32)
        else:
            self.meta = meta

    def evaluate_n(self, materials):
        """
        Evaluate the refractive index for each material for each ray in the set.
        """
        return tf.stack(tuple(mat(self.wv) for mat in materials), axis=1)

    def prepare_for_tracer(self, materials, extra=None):
        """
        Convert the ray data to tensors and return as a tuple (s, hat, n, meta) ready for the tracer.  Evaluates n.
        """
        if extra is not None:
            return (
                self.s,
                self.hat,
                self.evaluate_n(materials),
                self.meta,
                self.wv.numpy(),
                extra,
            )
        else:
            return (
                self.s,
                self.hat,
                self.evaluate_n(materials),
                self.meta,
                self.wv.numpy(),
            )

    @staticmethod
    def concatenate(raysets):
        raysets = tuple(rs for rs in raysets if rs.s.shape[0] > 0)
        if len(raysets) == 0:
            return RaySet3D()
        elif len(raysets) == 1:
            rayset = raysets[0]
            rayset.meta = tf.range(rayset.s.shape[0], dtype=tf.int32)
            return rayset
        else:
            s = tf.concat(tuple(rs.s for rs in raysets), axis=0)
            hat = tf.concat(tuple(rs.hat for rs in raysets), axis=0)
            wv = tf.concat(tuple(rs.wv for rs in raysets), axis=0)
            return RaySet3D(s, hat, wv, tf.range(s.shape[0], dtype=tf.int32))

    @property
    def s(self):
        return self._s

    @s.setter
    def s(self, val):
        self._s = tf.convert_to_tensor(val, dtype=tf.float64)

    @property
    def hat(self):
        return self._hat

    @hat.setter
    def hat(self, val):
        self._hat = tf.convert_to_tensor(val, dtype=tf.float64)

    @property
    def wv(self):
        return self._wv

    @wv.setter
    def wv(self, val):
        self._wv = tf.convert_to_tensor(val, dtype=tf.float64)

    @property
    def meta(self):
        return self._meta

    @meta.setter
    def meta(self, val):
        self._meta = tf.convert_to_tensor(val, dtype=tf.int32)

    def to_numpy(self):
        return self.s.numpy(), self.hat.numpy(), self.wv.numpy()

    @property
    def count(self):
        return self._s.shape[0]

    @property
    def end_points(self):
        return self._s + self._hat


class Source3D:
    """
    A three-dimensional ray source built from starting points, angles, and wavelengths

    All 3D sources are built centered on the origin with the rays starting on the x-y plane and the center of the
    output distribution pointing along the z-axis.  After these points are calculated, the source then rotates itself
    so it points along the direction specified in settings and then translates itself so it is centered at the
    position specified in settings.

    The public attributes listed below, or at least most of them, get updated on calling update().  This means that,
    if you are setting up the design problem as an imaging problem, you can get the starting points of the rays (points
    on the image) in order to set up the goal.

    Public Attributes
    -----------------
    rotation : quaternion
        A quaternion representing a rotation from the base orientation ((0, 0, 1), the z-axis) to angle.  Should
        be set in the settings (angle, a vector, not a quaternion) and generated by calling update_rotation()
    translation : 3-vector
        A translation vector applied to the source to move it.  Should be set in the settings (center) and generated
        by calling update_translation()
    start_points : array with shape (n, 3)
        The starting points of the rays, transformed
    base_start_points : array with shape (n, 3)
        The starting points, without the transformation applied.  These should be centered around the origin and
        pointing toward the z-axis.  These can be used to derive the goal in an imaging problem.
    end_points : array with shape (n, 3)
        The ending points of the rays, transformed
    base_end_points : array with shape (n, 3)
        The ending points, without the transformation applied.  These should be centered around the origin and
        pointing toward the z-axis.
    angles: array with shape (n, 3), or None
        The angles of the rays, transformed, as a vector.  Only valid if in angular mode, otherwise this is None.
    base_angles : array with shape (n, 3)
        The angles without the transformation applied.  Only valid if in angular mode, otherwise this is None.
    wavelengths : array with shape (n,)
        The wavelengths of each ray.
    rays : the ray data as a RaySet
    """
    BASE_ORIENTATION = np.array((0.0, 0.0, 1.0), dtype=np.float64)
    dimension = 3

    def __init__(
        self, driver, system_path, settings, wavelength, base_points=None, angles=None, aperture=None,
        aperture_distance=1.0
    ):
        """
        Parameters
        ----------
        settings : settings.Settings
            The settings for this component.
        wavelength :
            Many options for this parameter, that change how the class functions.
            If it is a callable:
                Must be a function that accepts an int, and generates an array containing that many floats which are
                the wavelengths in nanometers.
            If it is a wavelength.Spectrum:
                Will use this spectrum to generate the wavelengths.  See wavelength.Spectrum for details.
            If it is a str:
                Will be interpreted as a file path to a spectrum.  See wavelength.Spectrum for details.  Will generate a
                file selector widget to find this spectrum, and this parameter will only be used to set the default
                spectrum.  If given the empty string, will instead default to the default spectrum.
            If it is a float:
                Will be a constant used for all wavelengths.  Will generate a setting, 'wavelength' and a controller
                widget to make this parameter adjustable from the client.
            If it is a 2-tuple of floats:
                Will form a uniform spectrum between these two endpoints.  Will generate two settings, 'min_wavelength'
                and 'max_wavelength' and a controller to make these parameters adjustable from the client.
        base_points : distribution or None
            If None, this source will be a point source, with all rays emanating from a single point, the center set
            in the settings.  If non-none, this must be a callable that acts like a 2D distribution.  May also be a
            2d cumdistf distribution.  It must take a 2D set of points between zero and one and map them to some other
            distribution in 2D.  These points should be centered around the origin and will be treated as lying in the
            x=y plane.  The source assumes this position when translating and rotating the points into their final
            position.
        angles
        aperture
        aperture_distance : float, optional
            The distance between the optic center and the aperture.  Defaults to 1.  Only has an effect if aperture
            is specified.
        """
        self.driver = driver
        self.settings = settings
        self.settings.establish_defaults(
            ray_count=100,
            center=[0.0, 0.0, 0.0],
            angle=[0.0, 0.0, 1.0],
        )
        if self.driver.driver_type == "client":
            self.source_controller = SourceController(self)
            self.controller_widgets = [self.source_controller]
        else:
            self.source_controller = None
            self.controller_widgets = None
        self.system_path = system_path
        self.start_seed = None
        self.end_seed = None
        self.wavelength_seed = None

        self.make_wavelengths = self._process_wavelength(wavelength)
        self.base_points = self._register_controller(base_points)

        if angles is None:
            if aperture is None:
                raise ValueError("Source3D: Either angles or aperature must be specified")
            else:
                # in aperature mode
                self.make_end_points = self._register_controller(aperture)
                self.settings.establish_defaults(aperture_distance=aperture_distance)
                self._register_controller(cw.SettingsEntryBox(
                    self.settings, "aperture_distance", float, qtg.QDoubleValidator(1e-9, 1e6, 10)
                ))
        else:
            if aperture is None:
                # in angles mode
                self.make_end_points = self._register_controller(angles)
            else:
                raise ValueError("Source3D: Only one of angles or aperature can be specified - not both.")

        self.rotation = None
        self.update_rotation()
        self.translation = None
        self.update_translation()
        self.start_points = np.zeros((0, 3), dtype=np.float64)
        self.base_start_points = np.zeros((0, 3), dtype=np.float64)
        self.angles = None
        self.base_angles = None
        self.end_points = np.zeros((0, 3), dtype=np.float64)
        self.base_end_points = np.zeros((0, 3), dtype=np.float64)
        self.wavelengths = np.zeros((0, 3), dtype=np.float64)
        self.rays = RaySet3D()

    def update(self, ray_count_factor=None):
        if ray_count_factor is None:
            ray_count = self.settings.ray_count
        else:
            ray_count = math.floor(self.settings.ray_count * ray_count_factor)
        if self.settings.source_active:
            self.start_seed, self.end_seed, self.wavelength_seed = self.get_seeds(ray_count)
            base_start_points = self.make_start_points(self.start_seed)
            base_end_points = self.make_end_points(self.end_seed)
            if base_end_points.shape[1] == 2:
                # Is in aperture mode - need to expand to 3D
                base_end_points = np.pad(
                    base_end_points, ((0, 0), (0, 1)), constant_values=self.settings.aperture_distance
                )
            else:
                # Is in angles mode - need to make relative to base points
                base_end_points = tf.constant(base_end_points, dtype=tf.float64) + base_start_points

            # Do rotation / translation
            rotated_start_points = self.rotation.rotate(base_start_points)
            self.start_points = rotated_start_points + self.translation
            rotated_end_points = self.rotation.rotate(base_end_points)
            self.end_points = rotated_end_points + self.translation

            # set up wavelength mode
            self.wavelengths = self.make_wavelengths(self.wavelength_seed)
        else:
            self.start_seed = np.zeros((), dtype=np.float64)
            self.end_seed = np.zeros((), dtype=np.float64)
            self.wavelength_seed = np.zeros((), dtype=np.float64)
            self.start_points = np.zeros((0, 3), dtype=np.float64)
            self.end_points = np.zeros((0, 3), dtype=np.float64)

            # set up wavelength mode
            self.wavelengths = np.zeros((0,), dtype=np.float64)

        self.rays = RaySet3D(self.start_points, self.end_points - self.start_points, self.wavelengths)

    @staticmethod
    def get_seeds(count):
        start = np.random.uniform(size=(count, 2))
        end = np.random.uniform(size=(count, 2))
        wavelength = np.random.uniform(size=(count,))
        return start, end, wavelength

    def update_rotation(self):
        self.rotation = get_rotation_quaternion_from_u_to_v(
            self.BASE_ORIENTATION, np.array(self.settings.angle, dtype=np.float64)
        )

    def update_translation(self):
        self.translation = np.array(self.settings.center, dtype=np.float64)

    def refresh_from_settings(self):
        self.update_rotation()
        self.update_translation()

    def make_start_points(self, start_seed):
        if self.base_points is None:
            return np.zeros((start_seed.shape[0], 3), dtype=np.float64)
        else:
            points = self.base_points(start_seed)
            return np.pad(points, ((0, 0), (0, 1)))

    def _process_wavelength(self, wavelength):
        if callable(wavelength):
            return wavelength
        elif type(wavelength) is Spectrum:
            controller = SpectrumController(self, spectrum=wavelength)
            if self.driver.driver_type == "client":
                self.controller_widgets.append(controller)
            return controller
        elif type(wavelength) is str:
            if wavelength == "":
                wavelength = Path(__file__).parent / "default_spectrum.dat"
                self.settings.establish_defaults(spectrum_path=str(wavelength))
            controller = SpectrumController(self, path=wavelength)
            if self.driver.driver_type == "client":
                self.controller_widgets.append(controller)
            return controller
        else:
            try:
                wavelength = float(wavelength)
                self.settings.establish_defaults(wavelength=wavelength)
                if self.driver.driver_type == "client":
                    self.controller_widgets.append(cw.SettingsEntryBox(
                        self.settings, "wavelength", float, validator=qtg.QDoubleValidator(1e-3, 1e6, 8),
                        callback=self.source_controller.redraw
                    ))
                return self._make_constant_wavelengths
            except TypeError:
                try:
                    start, end = wavelength
                    start, end = float(start), float(end)
                    self.settings.establish_defaults(min_wavelength=start, max_wavelength=end)
                    if self.driver.driver_type == "client":
                        self.controller_widgets.append(cw.SettingsRangeBox(
                            self.settings, "wavelength range", "min_wavelength", "max_wavelength", float,
                            validator=qtg.QDoubleValidator(1e-3, 1e6, 8)
                        ))
                    return self._make_range_wavelengths
                except TypeError:
                    raise TypeError("Source3D: Could not interpret wavelength.")

    def _register_controller(self, arg):
        if isinstance(arg, qtw.QWidget) and self.driver.driver_type == "client":
            self.controller_widgets.append(arg)
        return arg

    def _make_constant_wavelengths(self, seed):
        return self.settings.wavelength * np.ones_like(seed, dtype=np.float64)

    def _make_range_wavelengths(self, seed):
        return seed * (self.settings.max_wavelength - self.settings.min_wavelength) + self.settings.min_wavelength


class SourceController(qtw.QWidget):
    def __init__(self, component):
        super().__init__()
        self.component = component

        # build the UI elements
        main_layout = qtw.QVBoxLayout()
        main_layout.setContentsMargins(11, 11, 0, 11)
        self.setLayout(main_layout)

        sub_layout = qtw.QHBoxLayout()
        sub_layout.addWidget(cw.SettingsEntryBox(
            self.component.settings, "ray_count", int, qtg.QIntValidator(1, 100000), self.redraw
        ))
        self.component.settings.establish_defaults(source_active=True)
        sub_layout.addWidget(cw.SettingsCheckBox(
            self.component.settings, "source_active", "Active", self.redraw
        ))
        main_layout.addLayout(sub_layout)
        main_layout.addWidget(cw.SettingsVectorBox(
            self.component.settings, "center", "center", [self.component.update_translation, self.redraw]
        ))
        main_layout.addWidget(cw.SettingsVectorBox(
            self.component.settings, "central angle", "angle", [self.component.update_rotation, self.redraw]
        ))

    def redraw(self):
        self.component.update()
        self.component.driver.trace_pane.redraw()
        self.component.driver.try_auto_retrace()


class SpectrumController(qtw.QWidget):
    def __init__(self, source, spectrum=None, path=None):
        self.source = source
        self.settings = source.settings
        self.spectral_plot = None
        super().__init__()
        layout = qtw.QVBoxLayout()
        layout.setContentsMargins(11, 11, 0, 11)
        self.setLayout(layout)
        self.loadable = False
        if path is None:
            if spectrum is None:
                raise ValueError("SpectrumController: either spectrum or path must be specified.")
            else:
                self.spectrum = spectrum
        else:
            if spectrum is not None:
                raise ValueError("SpectrumController: Only one of spectrum and path may be specified.")
            self.loadable = True
            self.settings.establish_defaults(spectrum_path=str(path))
            layout.addWidget(cw.SettingsFileBox(
                self.settings, "spectrum_path", self.source.system_path, filter="*.dat", mode="load",
                callback=self.load_spectrum
            ))

            # Checkbox and display for the spectrum
            self.settings.establish_defaults(show_spectrum=False)
            layout.addWidget(
                cw.SettingsCheckBox(self.source.settings, "show_spectrum", "Show spectrum", self.show_spectrum)
            )
            self.plot_widget = cw.MPLWidget(alignment=(0, .25, 1.0, .7))
            self.plot_widget.ax.yaxis.set_visible(False)
            self.plot_widget.ax.set_xlabel("Wavelength (nm)")
            self.plot_widget.setMinimumHeight(250)
            layout.addWidget(self.plot_widget)
            self.show_spectrum()

            self.load_spectrum()

    def load_spectrum(self):
        if self.loadable:
            self.plot_widget.ax.clear()
            self.spectrum = Spectrum.load(self.settings.spectrum_path)
            self.spectrum.plot_to_axis(self.plot_widget.ax, 100)
            self.plot_widget.draw()

    def show_spectrum(self):
        if self.settings.show_spectrum:
            self.plot_widget.show()
            self.plot_widget.draw()
        else:
            self.plot_widget.hide()

    def __call__(self, *args, **kwargs):
        return self.spectrum(*args, **kwargs)


def get_rotation_quaternion_from_u_to_v(u, v, epsilon=1e-6):
    """
    Return a quaternion that will rotate one vector u onto another, v.
    Given v amd u, this function computes q such that v = rotate_vector_by_quaternion(q, u).
    Pseudocode was adapted from https://stackoverflow.com/questions/1171849/finding-
    quaternion-representing-the-rotation-from-one-vector-to-another#:~:text=One%20
    solution%20is%20to%20compute,all%20the%20way%20to%20v!

    Parameters
    ----------

    u : numpy array of shape (..., 3)
    v : numpy array of shape (..., 3)
    epsilon: a float, optional.  A small number used to avoid divide by zero, which
        occurs when the rotation is a full flip (v -> -1)

    Returns
    -------
    A `Quaternion` with shape (..., 4)
    """
    u = normalize(u)
    v = normalize(v)

    # The dot / cross product determination produces twice the desired rotation.
    # Half the rotation can be accomplished by averaging the rotation produced here with a zero
    # rotation, which is accomplished by simply adding 1 to the dot product.
    dot = np.sum(u * v) + 1
    cross = np.cross(u, v)

    # If the rotation is a pure 180 flip then the dot product will be -1 and the cross
    # will be (0, 0, 0), so that quaternion generated will be a zero quaterion, which is
    # not correct.
    # We need to construct the quaternion (0, x, y, z) where (x, y, z) is any vector
    # orthogonal to u.  To get this, try u cross x-axis, and in the rare case where
    # that is zero because u is already the x-axis, then crossing with the y axis is
    # guarenteed to work, because there is no vector that can be orthogonal to both
    x_axis = np.broadcast_to((1.0, 0.0, 0.0), u.shape)
    y_axis = np.broadcast_to((0.0, 1.0, 0.0), u.shape)
    ortho_x = np.cross(u, x_axis)
    ortho_y = np.cross(u, y_axis)
    ortho = np.where(
        np.sum(ortho_x * ortho_x) < epsilon,
        ortho_y,
        ortho_x
    )

    q_untested = normalize(np.array((dot, *cross)))
    q_ortho = np.pad(ortho, (1, 0))
    quat = tf.where(
        tf.less(dot, epsilon),
        q_ortho,
        q_untested
    )
    return q.array(quat)


def normalize(a):
    """
    https://stackoverflow.com/questions/21030391/how-to-normalize-a-numpy-array-to-a-unit-vector
    """
    l2 = np.array(np.linalg.norm(a))
    l2[l2 == 0] = 1.0
    return a / l2
