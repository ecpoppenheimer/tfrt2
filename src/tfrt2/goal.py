"""
Manage the light output from an optical system, and define where you desire it to go.

A goal's purpose is to define how the light output from an optical system should be changed so as to make it...
'better'.  What 'goal' are you trying to achieve with this optical system?  A goal accomplishes its task in two major
steps.

The first step is wrangling whatever rays are output from the ray tracer into a defined region.  The goal only looks
at rays in the finished_rays rayset, which means an optical target is required by the system in order for the goal
to do anything useful.  Fortunately goals are able to make and manage their own targets, which will follow the goal as
it is transformed.  But this is not necessary - you may add additional targets to the optical system as you wish.  If
the optical system has no target, then it will not be able to generate any finished rays, and so the goal will be
useless.

Goal regions may be visualized with a mesh in the 3D view, but rays will not interact with these meshes - they are
strictly for debugging and development purposes.  Goal regions should only be 2D surfaces, and ideally be planar
surfaces, for sanity's sake, though it is possible I will implement non-planar goals some day.

Modes:

The second thing the goal does is determine where each finished ray should actually be, so it can tell the optimizer
how to change the system to make it better.  This behavior is controlled by the mode of the goal.  Mode cannot be
changed after instantiation.  Valid modes are:
    uniform: The goal will try to evenly fill its region with rays.
    cdf: The goal will use a CDF to fill its region non-uniformly.  In this mode, the parameter cdf is used.  It can
        have three meanings:  1) It can be a 2D float numpy array, representing the density of light that should be
        spread over the goal region.  2) It can be a cumdistf CumulativeDistributionFunction2D.  3) It can be a
        path to an image file that will be loaded, converted to grayscale, and used as the density function.  In
        this case, a UI element will be added to the goal that will enable picking this file.  This is the only option
        that allows the goal density to change after instantiation.
    none: No goal will be defined, so this system cannot perform optimization, but it can still be used for
        analysis.
    custom: This mode doesn't really do anything different from uniform mode, but it provides notification that the
        user is implementing their own code.  The design intent for this mode is for the user to subclass a goal and
        re-implement some functions (probably just flatten and expand) to tweak the performance.  This option isn't
        well tested or supported.
    imaging: This mode is not yet implemented.  This is the mode you would use to set up a traditional optical imaging
        problem, where the goal is to design a lens that produces a structured image of its target.  This is essentially
        the only mode that was supported in the original TFRT, where information generated by the sources was propagated
        through the system along with rays to be used at the destination to define where each ray should end up.  That
        technique works just fine, but I have found that I just did not need to use it very often.  Instead I have
        focused much more on projective lighting applications where the output distribution matters a great deal, and
        reconstructing the source is detrimental.
            This mode is not currently available because I have not written a way to propagate additional ray metadata
        through the ray tracing functions of tfrt2.  This would not be too difficult, but will require either a moderate
        performance hit (while using other modes) or writing a new, slightly modified version of
        trace_engine.get_trace_samples and trace_engine.precompiled_trace.
            One this is done, it will be easy enough to implement the rest of the logic.  Sources already publish their
        seeds and starting points as public attributes when they update.  One of these would have to be attached to
        the source rays as metadata, propagated through the tracer, and used to compute the goal.
            I will note that it could be possible to avoid the metadata propagation step.  If the tracing problem is so
        uniform that every ray will be guaranteed to interact the same number of times, it would be possible to simply
        match output rays to input rays, since the tracer does not cause rays to swap positions within the bundle.  But
        if even a single ray fails to finish, or undergoes a different reaction than all the others, then the data will
        not match up at the end of tracing.  This would be a highly fragile technique.


project() will gather finished rays from the system and project them into the goal region/plane.  It takes no arguments
and returns a set of 2D points.

flatten() will take the results from project (it calls project, so you do not need to) and uses an inverse cumulative
distribution function to map the points to a uniformly distributed set of 2D points in the domain [0, 1].  The
inverse CDF is efficient to compute but in order to be accurate it requires a representative histogram of ray data.
This is unfortunately an expensive operation to perform, requiring a large number of rays to be traced, but fortunately
this operation does not need to be performed very frequently.  It needs to be done a couple of times throughout
optimization as the output distribution changes.  I have not yet gathered enough experience to be able to judge how
frequently it needs to be updated but it does not need to be updated every training iteration.  It only really needs
to be updated when the output distribution changes substantially.  I have had good results updating it every 20-40
iterations.

In order for the results from flatten to be valid, the flattening_icdf has to be fed with feed_flatten(), at least
when in mode "uniform" and "cdf"

goal() will take the results from flatten, and pass them through whatever computation is required to take them
to the goal.  In 'uniform' or 'none' mode, this will do nothing, in 'cdf' mode, will pass them through the goal cdf.
In 'image' mode, this would extract the necessary information from the metadata and transform it.

expand() will move 2D rays in the plane of the goal surface (like the output from project) and move them into 3D, in
the appropriate position.

get_goal() is the full set of operations:  It gathers the finished rays from the system and determines where each
should end up, in 3D.

compute_error() is the function that will most frequently be used.  It takes the results computed from get_goal, and
performs a squared difference between the goal and the endpoints of the finished rays, which can be fed to an optimizer
as the error / loss.

error_function() is technically a public method, that could be overwritten.  It takes two parameters, output, and goal,
and computes the error.  By default, this is the squared difference, but I have experimented with different error
functions in the past, so I am leaving this open to experimentation.

"""

import traceback

import PyQt5.QtGui as qtg
import PyQt5.QtWidgets as qtw
import PyQt5.QtCore as qtc
import pyvista as pv
import numpy as np
import tensorflow as tf
from PIL import Image, ImageOps

from tfrt2.optics import TriangleOptic
from tfrt2.settings import Settings
import tfrt2.component_widgets as cw
import cumdistf.cdf as cdf


class CPlaneGoal:
    """
    This goal always lives in one of the three coordinate planes: "xy", "yz", "xz".
    """
    cord = {'x': 0, 'X': 0, 'y': 1, 'Y': 1, 'z': 2, 'Z': 2}

    def __init__(
        self, driver, system_settings, mode, c1, c2, c3_offset, goal_cdf=None, auto_target=True,
        auto_far_edge_distance=5, auto_far_back_distance=5, error_function=tf.math.squared_difference
    ):
        """
        Axis definition: This goal lives within two axes, which are specified with a 3-tuple of a letter followed
        by two floats.  The letter must be x, y, or z, and must be different for the two axes.  The two floats
        are the limits along that axis in which the goal lies.  For example, to make a goal on the xy plane between
        from x=1 to x=3 and from y=-1, to y=1, the axes could be specified as ('x', 1.0, 3.0), ('y', -1.0, 1.0).

        Parameters
        ----------
        driver : client.OpticClientWindow
            The top level client window.
        system_settings : settings.Settings
            Note the different convention: this is the system settings, not the component settings.  This
            class takes care of initializing its own settings.
        mode : str
            See the module documentation for a description of mode.
        c1 : 3-tuple
            See axis definition.
        c2 : 3-tuple
            See axis definition.
        c3_offset : float
            The offset of the plane in the remaining coordinate axis.
        goal_cdf : optional
            See module documentation / mode for a description.  Only has effect if mode is 'cdf'.
        auto_target : bool, optional
            Defaults to True, in which case a cubic target surface is generated and added to the optical system
        auto_far_edge_distance : float, optional
            Only has an effect when auto_target is set to True.  How much distance to place between the edge of the
            goal region and the walls of the target box.  Should be large enough to never clip any optical components.
        auto_far_back_distance : float, optional
            Only has an effect when auto_target is set to True.  How much distance behind the origin to place the
            back side of the target box.  Should be large enough to never clip any optical components.
        error_function : callable, optional
            The error function used by compute_error to convert the output and goal into a loss / error.  Defaults
            to tf.math.squared_difference.  This MUST be a tensorflow compatible operation if it is to be used
            with an optimizer.
        """
        self.driver = driver
        system_settings.establish_defaults(goal=Settings())
        self.settings = system_settings.goal
        self.settings.establish_defaults(
            c1=c1[0], c1_min=c1[1], c1_max=c1[2], c2=c2[0], c2_min=c2[1], c2_max=c2[2], visible=True,
            c3_offset=c3_offset, f_c1_res=64, f_c2_res=64, goal_color="#FFFFFF", flattener_ray_requirement=int(1e6)
        )
        self.auto_target = auto_target
        self.auto_far_edge_distance = auto_far_edge_distance
        self.auto_far_back_distance = auto_far_back_distance
        self.error_function = error_function

        # Validate mode
        if mode == "imaging":
            raise NotImplementedError("CPlaneGoal: imaging mode is desired but not yet implemented :(")
        elif mode not in {"uniform", "custom", "cdf", "none", None}:
            raise ValueError(
                f"CPlaneGoal: Invalid mode {mode}.  Must be in {{'uniform', 'cdf', 'imaging', 'custom', 'none'}}."
            )
        if mode is None:
            self._mode = "none"
        else:
            self._mode = mode

        # Set up the flattening icdf.  Valid for modes uniform, custom, and cdf.
        self.flatten_density = None
        if mode in {"uniform", "custom", "cdf"}:
            self.flattening_icdf = cdf.CumulativeDistributionFunction2D(
                ((0.0, 1.0), (0.0, 1.0)), direction="backward"
            )
            self.flatten = self.flattening_icdf.icdf
        else:
            self.flattening_icdf = None
            self.flatten = self._not_implemented

        # Set up the goal cdf
        self._loadable_cdf = False
        self.goal_density = np.ones((10, 10), dtype=np.int32)
        self.goal_density_texture = pv.numpy_to_texture(255 * np.ones((10, 10, 3)))
        if mode == "cdf":
            if type(goal_cdf) is str:
                # Make this a cdf that is loaded from an image
                self._loadable_cdf = True
                self.settings.establish_defaults(
                    goal_image=goal_cdf, goal_image_flip_x=False, goal_image_flip_y=False, goal_twist=False,
                    goal_test_point_count=0
                )
                self.goal_cdf = cdf.CumulativeDistributionFunction2D(
                        ((0.0, 1.0), (0.0, 1.0)), direction="forward", dtype=np.float64
                    )
            elif isinstance(goal_cdf, cdf.CumulativeDistributionFunction2D):
                # Easy, we were already handed a suitable CDF.
                self.goal_cdf = goal_cdf
            elif goal_cdf is None:
                # It wasn't specified
                raise ValueError("CPlaneGoal: parameter goal_cdf must be specified when in cdf mode.")
            else:
                # We hopefully received something that can be interpreted as a density
                try:
                    self.goal_cdf = cdf.CumulativeDistributionFunction2D(
                        ((0.0, 1.0), (0.0, 1.0)), density=goal_cdf, direction="forward"
                    )
                except Exception as e:
                    raise ValueError("CPlaneGoal: Could not interpret parameter goal_cdf as a density.") from e

            self.goal = self.goal_cdf.cdf

            # mesh to test the cdf
            self._goal_cdf_test_mesh = None
            self._goal_cdf_test_actor = None
        else:
            self.goal_cdf = None
            # for mode == 'uniform' or 'none', the correct goal function is a function that maps the region (0 -> 1)
            # onto the correct goal region.  It is just a simple linear re-scale.
            self.goal = self.shift_to_goal_region

        # Slicing and projection constants, that will move the 3D finished ray points into the 2D plane of the goal
        self._slice_1 = 0
        self._slice_2 = 1
        self._s1_clip_low = 0
        self._s1_clip_high = 1
        self._s2_clip_low = 0
        self._s2_clip_high = 1
        self._s3_offset = 0

        self.expand = None

        # If the driver is a client and not a server, make the parts to draw this goal
        self._drawable = self.driver.driver_type == "client"
        if self._drawable:
            self._mesh = pv.Plane(i_resolution=1, j_resolution=1).triangulate()
            self._actor = None
            self.remake_region_actor()

            self._goal_drawer = LineDrawer(self.driver.plot, self.settings.goal_color)

        # Make the UI widget
        self.controller = qtw.QWidget()
        main_layout = qtw.QGridLayout()
        main_layout.setContentsMargins(11, 11, 0, 11)
        self.controller.setLayout(main_layout)
        self.ui_row = 0

        main_layout.addWidget(qtw.QLabel("First coordinate axis"), self.ui_row, 0, 1, 6)
        self.ui_row += 1

        self.c1_box = cw.SettingsEntryBox(
            self.settings, "c1", str, validator=qtg.QRegExpValidator(qtc.QRegExp("[xyzXYZ]")),
            callback=self.refresh_from_settings
        )
        main_layout.addWidget(self.c1_box, self.ui_row, 0, 1, 2)
        main_layout.addWidget(cw.SettingsRangeBox(
            self.settings, "", "c1_min", "c1_max", float, validator=qtg.QDoubleValidator(-1e6, 1e6, 8),
            callback=self.refresh_from_settings
        ), self.ui_row, 2, 1, 4)
        self.ui_row += 1

        main_layout.addWidget(qtw.QLabel("Second coordinate axis"), self.ui_row, 0, 1, 6)
        self.ui_row += 1

        self.c2_box = cw.SettingsEntryBox(
            self.settings, "c2", str, validator=qtg.QRegExpValidator(qtc.QRegExp("[xyzXYZ]")),
            callback=self.refresh_from_settings
        )
        main_layout.addWidget(self.c2_box, self.ui_row, 0, 1, 2)
        main_layout.addWidget(cw.SettingsRangeBox(
            self.settings, "", "c2_min", "c2_max", float, validator=qtg.QDoubleValidator(-1e6, 1e6, 8),
            callback=self.refresh_from_settings
        ), self.ui_row, 2, 1, 4)
        self.ui_row += 1

        main_layout.addWidget(cw.SettingsEntryBox(
            self.settings, "c3_offset", float, validator=qtg.QDoubleValidator(-1e6, 1e6, 8),
            callback=self.refresh_from_settings
        ), self.ui_row, 0, 1, 3)

        # Visibility of the mesh
        main_layout.addWidget(cw.SettingsCheckBox(
            self.settings, "visible", "Visible", callback=self.refresh_from_settings
        ), self.ui_row, 3, 1, 3)
        self.ui_row += 1

        # Resolution of the flattening icdf.  Optional, because this will not exist for all modes
        if self.flattening_icdf is not None:
            main_layout.addWidget(cw.SettingsEntryBox(
                self.settings, "flattener_ray_requirement", int, validator=qtg.QIntValidator(int(1e4), int(1e9)),
                label="Minimum rays required for flattener"
            ), self.ui_row, 0, 1, 6)
            self.ui_row += 1
            main_layout.addWidget(cw.SettingsEntryBox(
                self.settings, "f_c1_res", int, validator=qtg.QIntValidator(1, int(1e6)),
                callback=self.refresh_from_settings
            ), self.ui_row, 0, 1, 3)
            main_layout.addWidget(cw.SettingsEntryBox(
                self.settings, "f_c2_res", int, validator=qtg.QIntValidator(1, int(1e6)),
                callback=self.refresh_from_settings
            ), self.ui_row, 3, 1, 3)
            self.ui_row += 1

        # File box to lad the goal cdf image, if needed.
        if self._loadable_cdf:
            main_layout.addWidget(qtw.QLabel("Path to the image to use as goal density"), self.ui_row, 0, 1, 6)
            self.ui_row += 1
            self.goal_image_file_selector = cw.SettingsFileBox(
                self.settings, "goal_image", self.driver.settings.system_path, mode="load",
                callback=self.load_goal_image
            )
            main_layout.addWidget(self.goal_image_file_selector, self.ui_row, 0, 1, 6)
            self.ui_row += 1

            # Controls for the orientation of the image
            main_layout.addWidget(cw.SettingsCheckBox(
                self.settings, "goal_image_flip_x", "Flip X", callback=self.load_goal_image
            ), self.ui_row, 0, 1, 2)
            main_layout.addWidget(cw.SettingsCheckBox(
                self.settings, "goal_image_flip_y", "Flip Y", callback=self.load_goal_image
            ), self.ui_row, 2, 1, 2)
            main_layout.addWidget(cw.SettingsCheckBox(
                self.settings, "goal_twist", "Twist", callback=self.load_goal_image
            ), self.ui_row, 4, 1, 2)
            self.ui_row += 1

            # Test the alignment of the CDF, by drawing a bunch of points
            test_goal_cdf_button = qtw.QPushButton("Test Goal CDF")
            test_goal_cdf_button.clicked.connect(self.try_draw_test_goal_cdf)
            main_layout.addWidget(test_goal_cdf_button, self.ui_row, 0, 1, 2)
            main_layout.addWidget(cw.SettingsEntryBox(
                self.settings, "goal_test_point_count", int, qtg.QIntValidator(0, 1e6), self.try_draw_test_goal_cdf
            ), self.ui_row, 2, 1, 4)
            self.ui_row += 1

        # Goal visualization tool
        main_layout.addWidget(qtw.QLabel("Goal visualization tool"), self.ui_row, 0, 1, 6)
        self.ui_row += 1

        main_layout.addWidget(qtw.QLabel("Show:"), self.ui_row, 0)
        self.visualize_selector = qtw.QComboBox()
        main_layout.addWidget(self.visualize_selector, self.ui_row, 1, 1, 3)
        self.visualize_selector.addItems(["None", "Projection"])
        if self.flattening_icdf is not None:
            self.visualize_selector.addItem("Flatten")
        self.visualize_selector.addItem("Goal")
        self.visualize_selector.activated.connect(self.try_redraw_goal)

        main_layout.addWidget(cw.ColorEntryButton(
            self.settings, "goal_color",
            callback=lambda: self._goal_drawer.set_color(self.settings.goal_color)
        ), self.ui_row, 4, 1, 2)
        self.ui_row += 1

        self.refresh_from_settings(init=True)
        if self._loadable_cdf:
            self.load_goal_image(init=True)
        self.try_redraw_goal()
        self.try_draw_test_goal_cdf()

    def refresh_from_settings(self, init=False):
        a1 = self.cord[self.settings.c1]
        a2 = self.cord[self.settings.c2]
        try:
            a3 = self.validate_axes(a1, a2)
        except ValueError:
            return

        if self._drawable:
            # Update the display of the mesh
            new_points = np.zeros((4, 3), dtype=np.float32)
            new_points[1, a1] = self.settings.c1_min
            new_points[1, a2] = self.settings.c2_min
            new_points[1, a3] = self.settings.c3_offset
            new_points[0, a1] = self.settings.c1_max
            new_points[0, a2] = self.settings.c2_min
            new_points[0, a3] = self.settings.c3_offset
            new_points[2, a1] = self.settings.c1_max
            new_points[2, a2] = self.settings.c2_max
            new_points[2, a3] = self.settings.c3_offset
            new_points[3, a1] = self.settings.c1_min
            new_points[3, a2] = self.settings.c2_max
            new_points[3, a3] = self.settings.c3_offset
            self._actor.SetVisibility(self.settings.visible)
            self._mesh.points = new_points

        # Slicing and projection constants, that will move the 3D finished ray points into the 2D plane of the goal.
        self._slice_1 = tf.constant(a1, dtype=tf.int32)
        self._slice_2 = tf.constant(a2, dtype=tf.int32)
        self._s1_clip_low = tf.constant(self.settings.c1_min, dtype=tf.float64)
        self._s1_clip_high = tf.constant(self.settings.c1_max, dtype=tf.float64)
        self._s2_clip_low = tf.constant(self.settings.c2_min, dtype=tf.float64)
        self._s2_clip_high = tf.constant(self.settings.c2_max, dtype=tf.float64)

        self._s3_offset = tf.constant(self.settings.c3_offset, dtype=tf.float64)

        # Expansion constant, so we know how to go back to 3D from a projection into the goal plane.  We are not
        # projection, just adding in the third coordinate.  I couldn't think of a more elegant way of doing this
        # at evaluation time within the limits of tensorflow, so just explicitly write out all three cases and pick
        # one.  Ugly but probably efficient
        if a1 == 0 and a2 == 1:
            self.expand = self._expand_1
        elif a1 == 1 and a2 == 2:
            self.expand = self._expand_2
        elif a1 == 0 and a2 == 2:
            self.expand = self._expand_3
        else:
            raise ValueError(f"Goal: reached invalid projection slice state {a1}, {a2}.")

        # Adjust the flattening icdf parameters, if it exists
        if self.flattening_icdf is not None:
            self.flattening_icdf.clear_density()
            self.flattening_icdf.x_min = self.settings.c1_min
            self.flattening_icdf.x_max = self.settings.c1_max
            self.flattening_icdf.y_min = self.settings.c2_min
            self.flattening_icdf.y_max = self.settings.c2_max
            if self.flatten_density is not None:
                self.flattening_icdf.set_resolution(*self.flatten_density.shape)
                self.flattening_icdf.compute(self.flatten_density, "inverse")

        # Rescale the goal_cdf
        if self.goal_cdf is not None:
            self.goal_cdf.clear_density()
            self.goal_cdf.set_resolution(*self.goal_density.shape)
            self.goal_cdf.x_min = self.settings.c1_min
            self.goal_cdf.x_max = self.settings.c1_max
            self.goal_cdf.y_min = self.settings.c2_min
            self.goal_cdf.y_max = self.settings.c2_max
            self.goal_cdf.compute(density=self.goal_density, direction="forward")

        self.try_redraw_goal(init)
        self.try_draw_test_goal_cdf(init)
        self.try_update_target(init)

    def try_redraw_goal(self, init=False):
        if init:
            return
        if not self._drawable or self.driver.optical_system is None:
            try:
                self._goal_drawer.lines = None
                self._goal_drawer.draw()
            except Exception:
                pass
            return

        try:
            mode = self.visualize_selector.currentText()
            if mode == "None":
                self._goal_drawer.lines = None
            else:
                rays = self.driver.optical_system.finished_rays
                start = rays[:, 3:6]
                if mode == "Projection":
                    end = self.project(rays)
                elif mode == "Flatten":
                    end = self.shift_to_goal_region(self.flatten(self.project(rays)))
                elif mode == "Goal":
                    end = self.goal(self.flatten(self.project(rays)))
                else:
                    return
                end = self.expand(end)

                self._goal_drawer.lines = start, end
            self._goal_drawer.draw()
        except cdf.ComputeRequiredError:
            self._goal_drawer.lines = None
            self._goal_drawer.draw()
            print(f"CPlaneGoal: Need to run output measurement before using a goal.")
        except Exception:
            self._goal_drawer.lines = None
            self._goal_drawer.draw()
            print(
                f"CPlaneGoal: Got exception while trying to draw the goal..."
            )
            print(traceback.format_exc())

    def validate_axes(self, a1, a2):
        a = {0, 1, 2} - {a1, a2}
        if a1 < a2:
            self.c1_box.edit_box.setStyleSheet("QLineEdit { background-color: white}")
            self.c2_box.edit_box.setStyleSheet("QLineEdit { background-color: white}")
            return a.pop()
        else:
            self.c1_box.edit_box.setStyleSheet("QLineEdit { background-color: pink}")
            self.c2_box.edit_box.setStyleSheet("QLineEdit { background-color: pink}")
            raise ValueError

    def project(self, rays):
        """
        Project and clip 3D rays into 2D in the plane of the goal.
        """
        # We don't need the full rays to perform this operation - just the end points.  So lets check if that
        # is what was fed.  If so, we don't want an offset.  Otherwise a full rayset was entered, which has
        # at least 7 elements, so we need an offset of 3 from the start to extract the end points.
        if rays.shape[1] == 3:
            offset = 0
        else:
            offset = 3
        x = np.clip(rays[:, offset+self._slice_1], self._s1_clip_low, self._s1_clip_high)
        y = np.clip(rays[:, offset+self._slice_2], self._s2_clip_low, self._s2_clip_high)
        return np.stack((x, y), axis=1)

    def shift_to_goal_region(self, points):
        """
        Takes the output from flatten (which lives in the domain (0, 1)) and move it to the goal region.

        This IS the goal function for uniform and custom modes.  For cdf mode, this functionality is accomplished
        by the cdf instead.
        """
        x = self._rescale(points[:, 0], self.settings.c1_min, self.settings.c1_max)
        y = self._rescale(points[:, 1], self.settings.c2_min, self.settings.c2_max)
        return np.stack((x, y), axis=1)

    @staticmethod
    def _rescale(n, n_min, n_max):
        n_is_safe = n != 0
        n_safe = np.where(n_is_safe, n, 1.0)
        return np.where(n_is_safe, n * (n_max - n_min) / np.amax(n_safe) + n_min, n_min)

    def _expand_1(self, points):
        s1, s2 = tf.unstack(points, axis=1)
        e = tf.ones_like(s1) * self._s3_offset
        return tf.stack((s1, s2, e), axis=1)

    def _expand_2(self, points):
        s1, s2 = tf.unstack(points, axis=1)
        e = tf.ones_like(s1) * self._s3_offset
        return tf.stack((e, s1, s2), axis=1)

    def _expand_3(self, points):
        s1, s2 = tf.unstack(points, axis=1)
        e = tf.ones_like(s1) * self._s3_offset
        return tf.stack((s1, e, s2), axis=1)

    def feed_flatten(self, points):
        if self.flattening_icdf is not None:
            proj = self.project(points)
            self.flattening_icdf.clear_density()
            self.flattening_icdf.set_resolution(self.settings.f_c1_res, self.settings.f_c2_res)
            density = self.flattening_icdf.histogram_points(proj)
            self.flattening_icdf.accumulate_density(density)
            self.flattening_icdf.compute(direction="inverse")
            return density
        else:
            # Can just ignore the data.  This is a valid thing that can happen, because I do not want the tracing
            # engine to have to decide whether or not to feed this data - it will just always feed it whether or not
            # it is needed.
            return None

    def remake_region_actor(self):
        if self._drawable:
            try:
                self.driver.plot.remove_actor(self._actor)
            except Exception:
                pass
            self._actor = self.driver.plot.add_mesh(self._mesh, texture=self.goal_density_texture)

    def load_goal_image(self, *args, init=False):
        # Need the *args to eat a parameter passed by the pyqt signal that calls this function whenever one of the
        # UI controls is used.
        if self._loadable_cdf and self.settings.goal_image != "":
            try:
                image = Image.open(self.settings.goal_image)
                self.goal_density = np.array(ImageOps.grayscale(image))
                if self.settings.goal_image_flip_x:
                    self.goal_density = np.flip(self.goal_density, 0)
                if self.settings.goal_image_flip_y:
                    self.goal_density = np.flip(self.goal_density, 1)
                if self.settings.goal_twist:
                    self.goal_density = np.rot90(self.goal_density, 1)
                self.goal_density_texture = pv.numpy_to_texture(self.goal_density)
                self.remake_region_actor()

                # The goal image and density are naturally out of sync, probably due to how the mesh is oriented
                # when it is generated.  We need to do various flips in different cases to get them to match up.
                self.goal_density = np.rot90(self.goal_density, 1)
                self.goal_density = np.flip(self.goal_density, 1)

                self.goal_cdf.clear_density()
                self.goal_cdf.set_resolution(*self.goal_density.shape)
                self.goal_cdf.compute(density=self.goal_density, direction="forward")
                try:
                    self.flattening_icdf.clear_density()
                except Exception:
                    pass
            except Exception:
                print(f"CPlaneGoal: Got exception while trying to load the goal image")
                self.goal_image_file_selector.notify_bad_selection()
                print(traceback.format_exc())

            self.try_draw_test_goal_cdf(init)

    def update(self):
        """
        This is the update function that will get called by system.update.  I will hopefully not need to do anything
        here, but this has to exist for compatibility with the optical system.
        """
        pass

    def try_draw_test_goal_cdf(self, init=False):
        if init:
            return
        try:
            self.driver.plot.remove_actor(self._goal_cdf_test_actor)
        except Exception:
            pass

        if (
            self._loadable_cdf and self.settings.goal_image != "" and self.expand is not None and
            self.goal_cdf is not None
        ):
            if self.settings.goal_test_point_count > 0:
                points = np.random.uniform(0.0, 1.0, (self.settings.goal_test_point_count, 2))
                expanded_points = self.expand(self.goal(points)).numpy()  # expand produces a tf.tensor
                self._goal_cdf_test_mesh = pv.PolyData(expanded_points)
                self._goal_cdf_test_actor = self.driver.plot.add_mesh(
                    self._goal_cdf_test_mesh, render_points_as_spheres=True, color="red", point_size=5
                )

    @property
    def mode(self):
        return self._mode

    def _not_implemented(self, *args, **kwargs):
        raise NotImplementedError(
            f"CPlaneGoal: in mode {self._mode} but a function was called that is either invalid for this mode or needs "
            "to be implemented by the user and was not."
        )

    def cleanup(self):
        try:
            self.driver.plot.remove_actor(self._goal_cdf_test_actor)
        except AttributeError:
            pass
        try:
            self.driver.plot.remove_actor(self._actor)
        except AttributeError:
            pass
        try:
            self._goal_drawer.cleanup()
        except AttributeError:
            pass

    def try_update_target(self, init=False):
        if not self.auto_target or init:
            return

        # a1 and a2 are the coordinate axes of the plane of the goal region, and a3 is the axis of its position
        # relative to the origin
        a1 = self.cord[self.settings.c1]
        a2 = self.cord[self.settings.c2]
        try:
            a3 = self.validate_axes(a1, a2)
        except ValueError:
            return

        a1_min = self.settings.c1_min - self.auto_far_edge_distance
        a1_max = self.settings.c1_max + self.auto_far_edge_distance
        a2_min = self.settings.c2_min - self.auto_far_edge_distance
        a2_max = self.settings.c2_max + self.auto_far_edge_distance
        if self.settings.c3_offset > 0:
            a3_min = -self.auto_far_back_distance
        else:
            a3_min = self.auto_far_back_distance
        a3_max = self.settings.c3_offset

        # Unfortunately they have to be ordered
        a1_min, a1_max = min(a1_min, a1_max), max(a1_min, a1_max)
        a2_min, a2_max = min(a2_min, a2_max), max(a2_min, a2_max)
        a3_min, a3_max = min(a3_min, a3_max), max(a3_min, a3_max)

        # Can use a* to feed these values to the right slot in the bounds
        bounds = [0] * 6
        bounds[2 * a1] = a1_min
        bounds[2 * a1 + 1] = a1_max
        bounds[2 * a2] = a2_min
        bounds[2 * a2 + 1] = a2_max
        bounds[2 * a3] = a3_min
        bounds[2 * a3 + 1] = a3_max

        try:
            self.driver.optical_system.parts["auto_target"].from_mesh(pv.Cube(bounds=bounds).triangulate())
            self.driver.optical_system.parts["auto_target"].drawer.draw()
        except KeyError:
            self.driver.optical_system.settings.establish_defaults(auto_target=Settings())
            self.driver.optical_system.settings.auto_target.establish_defaults(
                visible=False, show_edges=False, opacity=.5, color="pink"
            )
            target = TriangleOptic(
                self.driver, self.driver.settings.system_path, self.driver.optical_system.settings.auto_target,
                mesh=pv.Cube(bounds=bounds).triangulate()
            )
            target.name = "auto_target"
            self.driver.optical_system.parts["auto_target"] = target
            self.driver.optical_system.targets.append(target)

    def get_goal(self, ray_ends):
        if self.mode == "None":
            raise RuntimeError("Goal: Cannot call make_goal / use with an optimizer when in mode 'none'.")
        else:
            return self.expand(self.goal(self.flatten(self.project(ray_ends))))

    def compute_error(self):
        output = self.driver.optical_system.finished_rays[:, 3:6]
        goal = tf.convert_to_tensor(self.get_goal(output), dtype=tf.float64)
        return self.error_function(output, goal)


class LineDrawer:
    def __init__(self, plot, color):
        self.lines = None
        self.plot = plot
        self._mesh = pv.PolyData(
            np.array(((0, 0, 0), (1, 1, 1)), dtype=np.float32),
            lines=np.array((2, 0, 1), dtype=np.int32)
        )
        self._actor = None
        self.set_color(color)
        self._actor.SetVisibility(False)

    def set_color(self, color):
        self.plot.remove_actor(self._actor)
        self._actor = self.plot.add_mesh(self._mesh, color=color)

    def draw(self):
        """Redraw the pyvista actor controlled by this class."""
        try:
            start, end = self.lines

            line_count = start.shape[0]
            cell_range = np.arange(2 * line_count)
            cells = np.stack([
                2 * np.ones((line_count,), dtype=np.int32),
                cell_range[:line_count],
                cell_range[line_count:]
            ], axis=1).flatten()

            self._mesh.points = np.concatenate((start.numpy(), end.numpy()), axis=0)
            self._mesh.lines = cells
            self._actor.SetVisibility(True)
        except Exception:
            self._actor.SetVisibility(False)

    def cleanup(self):
        self.plot.remove_actor(self._actor)
